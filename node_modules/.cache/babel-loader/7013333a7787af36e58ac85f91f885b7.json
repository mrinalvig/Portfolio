{"ast":null,"code":"var lastTime; // Used to calculate deltaTime\n\nvar objs = []; // List of all GameObjects\n\nvar delList = [];\nvar scaleFact; // Amount to scale\n\nvar colBoxes = false; // Calculate the scaling factor\n\nfunction calcScaling() {\n  var oldFact = scaleFact; // Save the scale factor before we change it\n\n  var min; // The smaller viewport dimension in px\n\n  var des; // \"desired\" viewport dimension in px\n\n  viewport = new Vector2(window.innerWidth, window.innerHeight); // Find the right values\n\n  if (window.innerWidth <= window.innerHeight) {\n    min = window.innerWidth;\n    des = 256;\n  } else {\n    min = window.innerHeight;\n    des = 225;\n  } // Calculate, floor the value so we get an integer\n\n\n  scaleFact = Math.floor(min / des); // Make sure the factor isn't 0 or negative\n\n  if (scaleFact < 1) scaleFact = 1; // if the factor changed, resize all elements\n\n  if (scaleFact !== oldFact) {\n    // Resize the elements\n    //console.log(scaleFact);\n    // Resize the map\n    var cont = document.getElementById('map');\n    cont.style.height = mapArray.length * 16 * scaleFact + \"px\";\n    cont.style.width = mapArray[0].length * 16 * scaleFact + \"px\";\n\n    for (var i = 0; i < tiles.length; i++) {\n      tiles[i].elem.style.width = scaleFact * 16 + \"px\";\n      tiles[i].elem.style.height = scaleFact * 16 + \"px\";\n      tiles[i].elem.style.backgroundSize = scaleFact * 16 * 16 + \"px \" + scaleFact * 16 * 16 + \"px\";\n      tiles[i].elem.style.backgroundPosition = scaleFact * 16 * tiles[i].offX + \"px \" + scaleFact * 16 * tiles[i].offY + \"px\";\n    }\n\n    for (var i = 0; i < objs.length; i++) {\n      objs[i].elem.style.width = scaleFact * objs[i].spriteSize.x + \"px\";\n      objs[i].elem.style.height = scaleFact * objs[i].spriteSize.y + \"px\";\n      objs[i].resize();\n    }\n\n    if (player) {\n      player.resize();\n      player.elem.style.width = scaleFact * player.spriteSize.x + \"px\";\n      player.elem.style.height = scaleFact * player.spriteSize.y + \"px\";\n      player.elem.style.backgroundSize = scaleFact * player.animator.sheet.x + \"px \" + scaleFact * player.animator.sheet.y + \"px\";\n    }\n  }\n}\n\nwindow.onload = function () {\n  calcScaling();\n  entMain(0);\n  dungeon.musicPlay();\n};\n\nwindow.onresize = calcScaling; // Instance the player\n\nvar player = new Player(\"Player\");\nobjs.push(player); // Camera position\n\nvar camPos = new Vector2(0, 0);\n\nfunction delObject(obj) {\n  if (obj.active) {\n    obj.active = false;\n    delList.push(obj);\n  }\n}\n\nfunction cullObjects() {\n  for (var i = 0; i < delList.length; i++) {\n    document.body.removeChild(delList[i].elem);\n\n    if (colBoxes) {\n      document.body.removeChild(delList[i].box);\n    }\n\n    objs.splice(objs.indexOf(delList[i]), 1); //console.log(\"object deleted\");\n  } // Clear the list\n\n\n  delList = [];\n} // All game logic, physics, input, ai, etc\n\n\nfunction update(deltaTime) {\n  for (i = 0; i < objs.length; i++) {\n    objs[i].update(deltaTime);\n  }\n\n  cullObjects(); // Physics\n\n  var dt = deltaTime;\n\n  for (i = 0; i < objs.length; i++) {\n    if (objs[i].canCollide == false) {\n      for (j = 0; j < objs.length; j++) {\n        if (i != j) {\n          if (collides(objs[i], objs[j])) {\n            objs[i].collide(objs[j]);\n            objs[j].collide(objs[i]);\n          }\n        }\n      }\n    } else if (objs[i].velocity.x != 0 || objs[i].velocity.y != 0) {\n      var t = {\n        t: -1,\n        ax: false\n      };\n      var hit;\n\n      for (j = 0; j < objs.length; j++) {\n        if (i != j && objs[j].canCollide == true) {\n          var _t = phys(objs[i], objs[j], dt);\n\n          if (_t.t >= 0 && (_t.t < t.t || t.t < 0)) {\n            t = _t;\n            hit = objs[j];\n          }\n        }\n      }\n\n      for (var j = 0; j < collisionMap.length; j++) {\n        for (var k = 0; k < collisionMap[j].length; k++) {\n          if (collisionMap[j][k] == true) {\n            // Create a spoof gameobject for the phys function\n            var temp = {\n              position: new Vector2(k * 16, j * 16),\n              size: new Vector2(16, 16)\n            };\n\n            var _t = phys(objs[i], temp, dt);\n\n            if (_t.t >= 0 && (_t.t < t.t || t.t < 0)) {\n              t = _t;\n              hit = null;\n            }\n          }\n        }\n      }\n\n      var mag = objs[i].velocity.magnitude();\n\n      if (t.t >= 0 && mag > 0) {\n        var dir = objs[i].velocity.normalize();\n        objs[i].position = objs[i].position.add(dir.mul(t.t)); // Check the axis the collision happened on\n\n        if (t.ax) {\n          objs[i].velocity.y = 0;\n        } else {\n          objs[i].velocity.x = 0; //objs[i].velocity.y = 100;// objs[i].velocity.y * (1- Math.abs(dir.y));\n        } // If collision was with another obj, call the collide function\n\n\n        objs[i].collide(hit);\n\n        if (hit != null) {\n          hit.collide(objs[i]);\n        } // Basically repeat collision for this obj until dt <= 0\n\n\n        dt -= dt * (t.t / mag);\n\n        if (dt > 0) {\n          i--;\n          continue;\n        }\n      } else {\n        //if (mag > 0) console.log(\"no t + \" + t.t);\n        objs[i].position = objs[i].position.add(objs[i].velocity.mul(dt));\n      }\n    }\n\n    dt = deltaTime;\n  }\n\n  cullObjects();\n  pInput = Object.assign(pInput, input);\n}\n\nfunction draw(deltaTime) {\n  for (i = 0; i < objs.length; i++) {\n    objs[i].draw(deltaTime);\n  } //camPos = new Vector2(player.position.x - viewport.x / (2 * scaleFact), player.position.y - viewport.y / (2 * scaleFact));\n\n\n  if (player.position.x < camPos.x + viewport.x / (3 * scaleFact)) {\n    camPos.x = player.position.x - viewport.x / (3 * scaleFact);\n  }\n\n  if (player.position.x > camPos.x + 2 * viewport.x / (3 * scaleFact)) {\n    camPos.x = player.position.x - 2 * viewport.x / (3 * scaleFact);\n  }\n\n  if (player.position.y < camPos.y + viewport.y / (3 * scaleFact)) {\n    camPos.y = player.position.y - viewport.y / (3 * scaleFact);\n  }\n\n  if (player.position.y > camPos.y + 2 * viewport.y / (3 * scaleFact)) {\n    camPos.y = player.position.y - 2 * viewport.y / (3 * scaleFact);\n  } // Will also need to handle a moving camera\n\n\n  player.draw(deltaTime);\n  var cont = document.getElementById('map');\n  cont.style.left = -camPos.x * scaleFact + \"px\";\n  cont.style.top = -camPos.y * scaleFact + \"px\"; // TODO: Map drawing\n}\n\nvar slow = false; // Main loop function\n// Called as often as it can be\n\nfunction loop() {\n  // Get the delta time\n  // This is just the time that has passed since the last loop() call\n  // in seconds\n  // It will typically be 1/60\n  var deltaTime = 0.0;\n\n  if (typeof lastTime !== \"undefined\") {\n    deltaTime = (Date.now() - lastTime) / 1000.0;\n  } else {\n    deltaTime = 0;\n  }\n\n  lastTime = Date.now();\n  if (slow == true) deltaTime /= 58; // Get the fps, just cause\n\n  var fps = 1 / deltaTime; //if (fps < 40) console.log(\"Stutter \" + deltaTime * 1000 + \" ms \" + fps + \" fps\");\n  // Call the update function, all game logic, physics, input, ai, etc\n\n  update(deltaTime); // Draw the changes\n  // Really this just updates the CSS of the HTML objects\n\n  draw(deltaTime); // Let the browser update and then recall the loop function\n\n  requestAnimationFrame(loop);\n} // Jump into the loop, start the game\n\n\nrequestAnimationFrame(loop);","map":{"version":3,"sources":["/Users/mrinalvig/Documents/Projects/Portfolio/src/Game2.js"],"names":["lastTime","objs","delList","scaleFact","colBoxes","calcScaling","oldFact","min","des","viewport","Vector2","window","innerWidth","innerHeight","Math","floor","cont","document","getElementById","style","height","mapArray","length","width","i","tiles","elem","backgroundSize","backgroundPosition","offX","offY","spriteSize","x","y","resize","player","animator","sheet","onload","entMain","dungeon","musicPlay","onresize","Player","push","camPos","delObject","obj","active","cullObjects","body","removeChild","box","splice","indexOf","update","deltaTime","dt","canCollide","j","collides","collide","velocity","t","ax","hit","_t","phys","collisionMap","k","temp","position","size","mag","magnitude","dir","normalize","add","mul","pInput","Object","assign","input","draw","left","top","slow","loop","Date","now","fps","requestAnimationFrame"],"mappings":"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","sourcesContent":["var lastTime; // Used to calculate deltaTime\n\nvar objs = []; // List of all GameObjects\nvar delList = [];\n\nvar scaleFact; // Amount to scale\n\nvar colBoxes = false;\n\n// Calculate the scaling factor\nfunction calcScaling() {\n    var oldFact = scaleFact; // Save the scale factor before we change it\n    var min; // The smaller viewport dimension in px\n    var des; // \"desired\" viewport dimension in px\n\n    viewport = new Vector2(window.innerWidth, window.innerHeight);\n    // Find the right values\n    if (window.innerWidth <= window.innerHeight) {\n        min = window.innerWidth;\n        des = 256;\n\t} else {\n\t\tmin = window.innerHeight;\n\t\tdes = 225;\n\t}\n\n    // Calculate, floor the value so we get an integer\n\tscaleFact = Math.floor(min / des);\n\n    // Make sure the factor isn't 0 or negative\n\tif (scaleFact < 1) scaleFact = 1;\n\n    // if the factor changed, resize all elements\n    if (scaleFact !== oldFact) {\n        // Resize the elements\n        //console.log(scaleFact);\n\n\t\t// Resize the map\n\t\tvar cont = document.getElementById('map');\n\t\tcont.style.height = mapArray.length * 16 * scaleFact + \"px\";\n\t\tcont.style.width = mapArray[0].length * 16 * scaleFact + \"px\";\n\n\t\tfor (var i = 0; i < tiles.length; i++) {\n\t\t\ttiles[i].elem.style.width = scaleFact * 16 + \"px\";\n\t\t\ttiles[i].elem.style.height = scaleFact * 16 + \"px\";\n\t\t\ttiles[i].elem.style.backgroundSize = scaleFact * 16 * 16 + \"px \" + scaleFact * 16 * 16 + \"px\";\n\t\t\ttiles[i].elem.style.backgroundPosition = scaleFact * 16 * tiles[i].offX + \"px \" + scaleFact * 16 * tiles[i].offY + \"px\";\n\t\t}\n\n\t\tfor (var i = 0; i < objs.length; i++) {\n            objs[i].elem.style.width = scaleFact * objs[i].spriteSize.x + \"px\";\n            objs[i].elem.style.height = scaleFact * objs[i].spriteSize.y + \"px\";\n            objs[i].resize();\n\t\t}\n        if (player) {\n            player.resize();\n            player.elem.style.width = scaleFact * player.spriteSize.x + \"px\";\n            player.elem.style.height = scaleFact * player.spriteSize.y + \"px\";\n            player.elem.style.backgroundSize = scaleFact * player.animator.sheet.x + \"px \" + scaleFact * player.animator.sheet.y + \"px\";\n        }\n    }\n}\n\nwindow.onload = function () {\n\tcalcScaling();\n\tentMain(0);\n\tdungeon.musicPlay()\n}\n\nwindow.onresize = calcScaling;\n\n// Instance the player\nvar player = new Player(\"Player\");\nobjs.push(player);\n\n// Camera position\nvar camPos = new Vector2(0, 0);\n\n\nfunction delObject(obj) {\n\tif (obj.active) {\n\t\tobj.active = false;\n\t\tdelList.push(obj);\n\t}\n}\n\nfunction cullObjects() {\n\tfor (var i = 0; i < delList.length; i++) {\n\t\tdocument.body.removeChild(delList[i].elem);\n\n\t\tif (colBoxes) {\n\t\t\tdocument.body.removeChild(delList[i].box);\n\t\t}\n\n\t\tobjs.splice(objs.indexOf(delList[i]), 1);\n\t\t//console.log(\"object deleted\");\n\t}\n\t\n\t// Clear the list\n\tdelList = [];\n}\n\n// All game logic, physics, input, ai, etc\nfunction update(deltaTime) {\n    for (i = 0; i < objs.length; i++) {\n        objs[i].update(deltaTime);\n    }\n\n\tcullObjects();\n\t\n    // Physics\n    var dt = deltaTime;\n\tfor (i = 0; i < objs.length; i++) {\n\n        if (objs[i].canCollide == false) {\n            for (j = 0; j < objs.length; j++) {\n                if (i != j) {\n                    if (collides(objs[i], objs[j])) {\n                        objs[i].collide(objs[j]);\n                        objs[j].collide(objs[i]);\n                    }\n                }\n            }\n        } else if (objs[i].velocity.x != 0 || objs[i].velocity.y != 0){\n\n            var t = {t:-1, ax: false};\n            var hit;\n            for (j = 0; j < objs.length; j++) {\n                if (i != j && objs[j].canCollide == true) {\n                    var _t = phys(objs[i], objs[j], dt);\n                    if (_t.t >= 0 && (_t.t < t.t || t.t < 0)) {\n                        t = _t;\n                        hit = objs[j];\n                    }\n                }\n            }\n\n            for (var j = 0; j < collisionMap.length; j++) {\n                for (var k = 0; k < collisionMap[j].length; k++) {\n                    if (collisionMap[j][k] == true) {\n                        // Create a spoof gameobject for the phys function\n                        var temp = {position: new Vector2(k * 16, j * 16), size: new Vector2(16,16)};\n                        var _t = phys(objs[i], temp, dt);\n                        if (_t.t >= 0 && (_t.t < t.t || t.t < 0)) {\n                            t = _t;\n                            hit = null;\n                        }\n                    }\n                }\n            }\n\n            var mag = objs[i].velocity.magnitude();\n            if (t.t >= 0 && mag > 0) {\n                var dir = objs[i].velocity.normalize();\n\n                objs[i].position = objs[i].position.add(dir.mul(t.t));\n\n                // Check the axis the collision happened on\n                if (t.ax) {\n                    objs[i].velocity.y = 0;\n                } else {\n\n                    objs[i].velocity.x = 0;\n                    //objs[i].velocity.y = 100;// objs[i].velocity.y * (1- Math.abs(dir.y));\n                }\n\n                // If collision was with another obj, call the collide function\n\t\t\t\tobjs[i].collide(hit);\n                if (hit != null) {\n                    hit.collide(objs[i]);\n                }\n\n\n                // Basically repeat collision for this obj until dt <= 0\n                dt -= dt * (t.t/mag);\n                if (dt > 0) {\n                    i--;\n                    continue;\n                }\n\n            } else {\n                //if (mag > 0) console.log(\"no t + \" + t.t);\n                objs[i].position = objs[i].position.add(objs[i].velocity.mul(dt));\n            }\n        }\n        dt = deltaTime;\n    }\n\n\tcullObjects();\n\t\n    pInput = Object.assign(pInput, input);\n}\n\nfunction draw(deltaTime) {\n\tfor (i = 0; i < objs.length; i++) {\n\t\tobjs[i].draw(deltaTime);\n\t}\n  //camPos = new Vector2(player.position.x - viewport.x / (2 * scaleFact), player.position.y - viewport.y / (2 * scaleFact));\n\n  if (player.position.x < camPos.x + viewport.x / (3 * scaleFact)) {\n    camPos.x = player.position.x - viewport.x / (3 * scaleFact);\n  }\n\n  if (player.position.x > camPos.x + 2 * viewport.x / (3 * scaleFact)) {\n    camPos.x = player.position.x - 2 * viewport.x / (3 * scaleFact);\n  }\n\n  if (player.position.y < camPos.y + viewport.y / (3 * scaleFact)) {\n    camPos.y = player.position.y - viewport.y / (3 * scaleFact);\n  }\n\n  if (player.position.y > camPos.y + 2 * viewport.y / (3 * scaleFact)) {\n    camPos.y = player.position.y - 2 * viewport.y / (3 * scaleFact);\n  }\n\n     // Will also need to handle a moving camera\n\tplayer.draw(deltaTime);\n\n  var cont = document.getElementById('map');\n\n\n  cont.style.left = -camPos.x * scaleFact + \"px\";\n  cont.style.top = -camPos.y * scaleFact + \"px\";\n\n    // TODO: Map drawing\n}\nvar slow = false;\n\n// Main loop function\n// Called as often as it can be\nfunction loop() {\n    // Get the delta time\n    // This is just the time that has passed since the last loop() call\n    // in seconds\n    // It will typically be 1/60\n    var deltaTime = 0.0;\n    if (typeof lastTime !== \"undefined\") {\n        deltaTime = (Date.now() - lastTime) / 1000.0;\n    } else {\n        deltaTime = 0;\n    }\n    lastTime = Date.now();\n\n    if (slow == true) deltaTime /= 58;\n\n    // Get the fps, just cause\n    var fps = 1 / deltaTime;\n    //if (fps < 40) console.log(\"Stutter \" + deltaTime * 1000 + \" ms \" + fps + \" fps\");\n\n    // Call the update function, all game logic, physics, input, ai, etc\n    update(deltaTime);\n\n    // Draw the changes\n    // Really this just updates the CSS of the HTML objects\n    draw(deltaTime);\n\n    // Let the browser update and then recall the loop function\n    requestAnimationFrame(loop);\n}\n\n// Jump into the loop, start the game\nrequestAnimationFrame(loop);\n"]},"metadata":{},"sourceType":"module"}